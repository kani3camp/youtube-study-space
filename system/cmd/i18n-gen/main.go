package main

import (
	"bufio"
	"bytes"
	"errors"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"

	"github.com/BurntSushi/toml"
)

const (
	// Relative paths from module root
	metaRelPath   = "core/i18n/meta/i18n_meta.toml"
	localesRelDir = "core/i18n/locales"
	outRelPath    = "core/i18n/typed/zz_generated.i18n_messages.go"

	outputPkgName = "i18nmsg"

	i18nImportPath = "app.modules/core/i18n/internal/engine"

	baselineLang = "ja"
)

// Simple meta format:
// [namespace]
// key = ["name: type", ...]

type metaDataType = map[string]map[string][]string

type localeData = map[string]map[string]string

var (
	nsHeaderRe = regexp.MustCompile(`^\s*\[\s*([^\]]+)\s*\]\s*$`)
	keyLineRe  = regexp.MustCompile(`^\s*([A-Za-z0-9_\-]+)\s*=\s*\[`)
	phRe       = regexp.MustCompile(`\{(\d+)\}`)
)

type orderedKey struct {
	namespace string
	key       string
}

func main() {
	wd, _ := os.Getwd()
	moduleRoot, err := findModuleRoot(wd)
	if err != nil {
		panic(err)
	}
	metaPath := filepath.Join(moduleRoot, metaRelPath)
	localesDir := filepath.Join(moduleRoot, localesRelDir)
	outPath := filepath.Join(moduleRoot, outRelPath)

	// Load meta (structured)
	var meta metaDataType
	if _, err := toml.DecodeFile(metaPath, &meta); err != nil {
		panic(fmt.Errorf("decode meta: %w", err))
	}

	// Read meta raw to preserve order
	rawBytes, err := os.ReadFile(metaPath)
	if err != nil {
		panic(err)
	}
	ordered := extractOrder(string(rawBytes))
	if len(ordered) == 0 {
		panic("meta has no keys")
	}

	// Load locales
	entries, err := os.ReadDir(localesDir)
	if err != nil {
		panic(err)
	}
	locales := map[string]localeData{}
	for _, e := range entries {
		if e.IsDir() || !strings.HasSuffix(e.Name(), ".toml") {
			continue
		}
		var ld localeData
		if _, err := toml.DecodeFile(filepath.Join(localesDir, e.Name()), &ld); err != nil {
			panic(fmt.Errorf("decode locale %s: %w", e.Name(), err))
		}
		lang := strings.TrimSuffix(e.Name(), ".toml")
		locales[lang] = ld
	}
	if len(locales) == 0 {
		panic("no locales found")
	}

	// Generate
	var out bytes.Buffer
	out.WriteString("// Code generated by i18n-gen; DO NOT EDIT.\n")
	out.WriteString(fmt.Sprintf("package %s\n\n", outputPkgName))
	out.WriteString("import (\n\t\"")
	out.WriteString(i18nImportPath)
	out.WriteString("\"\n)\n\n")

	for _, ok := range ordered {
		argsList, okMeta := getArgs(meta, ok.namespace, ok.key)
		if !okMeta {
			panic(fmt.Errorf("meta missing args for %s:%s", ok.namespace, ok.key))
		}

		// Validate using baseline locale (ja). Other locales are best-effort (warn only).
		base, okBase := locales[baselineLang]
		if !okBase {
			panic(fmt.Sprintf("baseline locale %q not found under %s", baselineLang, localesRelDir))
		}
		baseMsg := base[ok.namespace][ok.key]
		if baseMsg == "" {
			panic(fmt.Errorf("missing baseline locale (ja): %s.%s", ok.namespace, ok.key))
		}
		expected := countPlaceholders(baseMsg)
		if expected != len(argsList) {
			panic(fmt.Errorf("meta args mismatch: %s.%s expects %d, meta has %d", ok.namespace, ok.key, expected, len(argsList)))
		}
		for lang, ld := range locales {
			if lang == "ja" {
				continue
			}
			msg := ld[ok.namespace][ok.key]
			if msg == "" {
				warnf("[i18n-gen] missing locale %s: %s.%s\n", lang, ok.namespace, ok.key)
				continue
			}
			if countPlaceholders(msg) != expected {
				warnf("[i18n-gen] placeholder mismatch in %s for %s.%s (expected %d)\n", lang, ok.namespace, ok.key, expected)
			}
		}

		// Build function
		funcName := toExportedName(ok.namespace, ok.key)
		out.WriteString(fmt.Sprintf("// %s: key %q\n", funcName, ok.namespace+":"+ok.key))
		out.WriteString(fmt.Sprintf("func %s(", funcName))
		for i, raw := range argsList {
			name, typ, err := parseArgSpec(raw)
			if err != nil {
				panic(fmt.Errorf("%s.%s arg %d: %w", ok.namespace, ok.key, i, err))
			}
			if i > 0 {
				out.WriteString(", ")
			}
			out.WriteString(fmt.Sprintf("%s %s", name, typ))
		}
		out.WriteString(") string {\n")
		out.WriteString(fmt.Sprintf("\treturn engine.TranslateDefault(%q", ok.namespace+":"+ok.key))
		for _, raw := range argsList {
			name, _, _ := parseArgSpec(raw)
			out.WriteString(", ")
			out.WriteString(name)
		}
		out.WriteString(")\n}\n\n")
	}

	if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil {
		panic(err)
	}
	if err := os.WriteFile(outPath, out.Bytes(), 0o644); err != nil {
		panic(err)
	}
}

func findModuleRoot(start string) (string, error) {
	dir := start
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return "", fmt.Errorf("go.mod not found from %s", start)
}

func extractOrder(content string) []orderedKey {
	var ordered []orderedKey
	currentNS := ""
	scanner := bufio.NewScanner(strings.NewReader(content))
	for scanner.Scan() {
		line := scanner.Text()
		// Remove comments after content for matching lines that start comments
		if strings.HasPrefix(strings.TrimSpace(line), "#") || strings.TrimSpace(line) == "" {
			continue
		}
		if m := nsHeaderRe.FindStringSubmatch(line); m != nil {
			currentNS = strings.TrimSpace(m[1])
			continue
		}
		if currentNS != "" {
			if m := keyLineRe.FindStringSubmatch(line); m != nil {
				k := strings.TrimSpace(m[1])
				ordered = append(ordered, orderedKey{namespace: currentNS, key: k})
			}
		}
	}
	return ordered
}

func getArgs(meta metaDataType, ns, key string) ([]string, bool) {
	m, ok := meta[ns]
	if !ok {
		return nil, false
	}
	a, ok := m[key]
	return a, ok
}

func countPlaceholders(s string) int {
	matches := phRe.FindAllStringSubmatch(s, -1)
	max := -1
	for _, g := range matches {
		if len(g) < 2 {
			continue
		}
		idx := atoiSafe(g[1])
		if idx > max {
			max = idx
		}
	}
	return max + 1
}

func atoiSafe(s string) int {
	n := 0
	for _, r := range s {
		if r < '0' || r > '9' {
			break
		}
		n = n*10 + int(r-'0')
	}
	return n
}

func toExportedName(ns, key string) string {
	conv := func(s string) string {
		s = strings.ReplaceAll(s, "-", " ")
		s = strings.ReplaceAll(s, "_", " ")
		parts := strings.Fields(s)
		for i, p := range parts {
			if len(p) == 0 {
				continue
			}
			parts[i] = strings.ToUpper(p[:1]) + p[1:]
		}
		// join and strip non-alphanumeric
		joined := strings.Join(parts, "")
		b := strings.Builder{}
		for _, r := range joined {
			if (r >= 'A' && r <= 'Z') || (r >= 'a' && r <= 'z') || (r >= '0' && r <= '9') {
				b.WriteRune(r)
			}
		}
		out := b.String()
		if out == "" {
			out = "Key"
		}
		// ensure starts with letter for exported name
		r0 := rune(out[0])
		if !((r0 >= 'A' && r0 <= 'Z') || (r0 >= 'a' && r0 <= 'z')) {
			out = "Key" + out
		}
		return out
	}
	return conv(ns) + conv(key)
}

func parseArgSpec(s string) (string, string, error) {
	parts := strings.SplitN(s, ":", 2)
	if len(parts) != 2 {
		return "", "", fmt.Errorf("arg %q must be 'name: type'", s)
	}
	name := sanitizeIdent(strings.TrimSpace(parts[0]))
	typ := strings.TrimSpace(parts[1])
	if !isSupportedType(typ) {
		return "", "", fmt.Errorf("unsupported type %q", typ)
	}
	if name == "" {
		return "", "", errors.New("empty arg name")
	}
	return name, typ, nil
}

func sanitizeIdent(s string) string {
	if s == "" {
		return s
	}
	b := strings.Builder{}
	// If first char is not letter or underscore, prefix underscore
	r0 := rune(s[0])
	if !(r0 == '_' || (r0 >= 'A' && r0 <= 'Z') || (r0 >= 'a' && r0 <= 'z')) {
		b.WriteByte('_')
	}
	for _, r := range s {
		if r == '_' || (r >= 'A' && r <= 'Z') || (r >= 'a' && r <= 'z') || (r >= '0' && r <= '9') {
			b.WriteRune(r)
		} else {
			b.WriteByte('_')
		}
	}
	return b.String()
}

func isSupportedType(t string) bool {
	switch t {
	case "string", "int", "int64", "float64", "bool":
		return true
	default:
		return false
	}
}

func warnf(format string, a ...any) {
	fmt.Fprintf(os.Stderr, format, a...)
}
