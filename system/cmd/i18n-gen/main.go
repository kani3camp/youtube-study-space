package main

import (
	"bufio"
	"bytes"
	"errors"
	"flag"
	"fmt"
	"os"
	"path/filepath"
	"regexp"
	"strings"
	"time"

	"github.com/BurntSushi/toml"
)

const (
	// Relative paths from module root
	metaRelPath   = "core/i18n/meta/i18n_meta.toml"
	localesRelDir = "core/i18n/locales"
	outRelPath    = "core/i18n/typed/zz_generated.i18n_messages.go"

	outputPkgName = "i18nmsg"

	i18nImportPath = "app.modules/core/i18n/internal/engine"

	defaultBaselineLang = "ja"
)

// Simple meta format:
// [namespace]
// key = ["name: type", ...]

type metaDataType = map[string]map[string][]string

type localeData = map[string]map[string]string

var (
	nsHeaderRe = regexp.MustCompile(`^\s*\[\s*([^\]]+)\s*\]\s*$`)
	keyLineRe  = regexp.MustCompile(`^\s*([A-Za-z0-9_\-]+)\s*=\s*\[`)
	phRe       = regexp.MustCompile(`\{(\d+)\}`)
)

type orderedKey struct {
	namespace string
	key       string
}

func main() {
	// Flags and environment overrides
	baselineFlag := flag.String("baseline", "", "baseline locale language code (default: ja) or I18N_BASELINE env")
	flag.Parse()

	baselineLang := defaultBaselineLang
	if *baselineFlag != "" {
		baselineLang = *baselineFlag
	} else if bl := os.Getenv("I18N_BASELINE"); bl != "" {
		baselineLang = bl
	}
	// Always fail fast on translation issues

	wd, _ := os.Getwd()
	moduleRoot, err := findModuleRoot(wd)
	if err != nil {
		panic(err)
	}
	metaPath := filepath.Join(moduleRoot, metaRelPath)
	localesDir := filepath.Join(moduleRoot, localesRelDir)
	outPath := filepath.Join(moduleRoot, outRelPath)

	// Load meta (structured)
	var meta metaDataType
	if _, err := toml.DecodeFile(metaPath, &meta); err != nil {
		panic(fmt.Errorf("decode meta: %w", err))
	}

	// Read meta raw to preserve order
	rawBytes, err := os.ReadFile(metaPath)
	if err != nil {
		panic(err)
	}
	ordered := extractOrder(string(rawBytes))
	if len(ordered) == 0 {
		panic("meta has no keys")
	}

	// Load locales
	entries, err := os.ReadDir(localesDir)
	if err != nil {
		panic(err)
	}
	locales := map[string]localeData{}
	for _, e := range entries {
		if e.IsDir() || !strings.HasSuffix(e.Name(), ".toml") {
			continue
		}
		var ld localeData
		if _, err := toml.DecodeFile(filepath.Join(localesDir, e.Name()), &ld); err != nil {
			panic(fmt.Errorf("decode locale %s: %w", e.Name(), err))
		}
		lang := strings.TrimSuffix(e.Name(), ".toml")
		locales[lang] = ld
	}
	if len(locales) == 0 {
		panic("no locales found")
	}

	// Generate
	var out bytes.Buffer
	out.WriteString("// Code generated by i18n-gen; DO NOT EDIT.\n")
	out.WriteString(fmt.Sprintf("// Generated at %s by i18n-gen; baseline=%s\n", time.Now().UTC().Format(time.RFC3339), baselineLang))
	out.WriteString(fmt.Sprintf("package %s\n\n", outputPkgName))
	out.WriteString("import (\n\t\"")
	out.WriteString(i18nImportPath)
	out.WriteString("\"\n)\n\n")

	for _, ok := range ordered {
		argsList, okMeta := getArgs(meta, ok.namespace, ok.key)
		if !okMeta {
			panic(fmt.Errorf("meta missing args for %s:%s", ok.namespace, ok.key))
		}

		// Validate using baseline locale. Other locales must also satisfy constraints.
		base, okBase := locales[baselineLang]
		if !okBase {
			panic(fmt.Sprintf("baseline locale %q not found under %s", baselineLang, localesRelDir))
		}
		baseMsg := base[ok.namespace][ok.key]
		if baseMsg == "" {
			panic(fmt.Errorf("missing baseline locale (%s): %s.%s", baselineLang, ok.namespace, ok.key))
		}
		expected := countPlaceholders(baseMsg)
		if expected != len(argsList) {
			panic(fmt.Errorf("meta args mismatch: %s.%s expects %d, meta has %d", ok.namespace, ok.key, expected, len(argsList)))
		}
		if err := validateSequentialPlaceholders(baseMsg, expected); err != nil {
			panic(fmt.Errorf("invalid placeholder sequence in baseline locale (%s): %s.%s: %w", baselineLang, ok.namespace, ok.key, err))
		}
		for lang, ld := range locales {
			if lang == baselineLang {
				continue
			}
			msg := ld[ok.namespace][ok.key]
			if msg == "" {
				panic(fmt.Errorf("missing translation for locale %s: %s.%s", lang, ok.namespace, ok.key))
			}
			if countPlaceholders(msg) != expected {
				panic(fmt.Errorf("placeholder mismatch in %s for %s.%s (expected %d)", lang, ok.namespace, ok.key, expected))
			}
			if err := validateSequentialPlaceholders(msg, expected); err != nil {
				panic(fmt.Errorf("invalid placeholder sequence in %s for %s.%s: %w", lang, ok.namespace, ok.key, err))
			}
		}

		// Build function
		funcName := toExportedName(ok.namespace, ok.key)
		out.WriteString(fmt.Sprintf("// %s: key %q\n", funcName, ok.namespace+":"+ok.key))
		out.WriteString(fmt.Sprintf("func %s(", funcName))
		for i, raw := range argsList {
			name, typ, err := parseArgSpec(raw)
			if err != nil {
				panic(fmt.Errorf("%s.%s arg %d: %w", ok.namespace, ok.key, i, err))
			}
			if i > 0 {
				out.WriteString(", ")
			}
			out.WriteString(fmt.Sprintf("%s %s", name, typ))
		}
		out.WriteString(") string {\n")
		out.WriteString(fmt.Sprintf("\treturn engine.TranslateDefault(%q", ok.namespace+":"+ok.key))
		for _, raw := range argsList {
			name, _, _ := parseArgSpec(raw)
			out.WriteString(", ")
			out.WriteString(name)
		}
		out.WriteString(")\n}\n\n")
	}

	if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil {
		panic(err)
	}
	// Normalize trailing newlines: ensure exactly one newline at EOF
	content := out.Bytes()
	for len(content) > 0 {
		last := content[len(content)-1]
		if last == '\n' || last == '\r' {
			content = content[:len(content)-1]
			continue
		}
		break
	}
	content = append(content, '\n')
	if err := os.WriteFile(outPath, content, 0o644); err != nil {
		panic(err)
	}
}

func findModuleRoot(start string) (string, error) {
	dir := start
	for {
		if _, err := os.Stat(filepath.Join(dir, "go.mod")); err == nil {
			return dir, nil
		}
		parent := filepath.Dir(dir)
		if parent == dir {
			break
		}
		dir = parent
	}
	return "", fmt.Errorf("go.mod not found from %s", start)
}

func extractOrder(content string) []orderedKey {
	var ordered []orderedKey
	currentNS := ""
	scanner := bufio.NewScanner(strings.NewReader(content))
	for scanner.Scan() {
		line := scanner.Text()
		// Remove comments after content for matching lines that start comments
		if strings.HasPrefix(strings.TrimSpace(line), "#") || strings.TrimSpace(line) == "" {
			continue
		}
		if m := nsHeaderRe.FindStringSubmatch(line); m != nil {
			currentNS = strings.TrimSpace(m[1])
			continue
		}
		if currentNS != "" {
			if m := keyLineRe.FindStringSubmatch(line); m != nil {
				k := strings.TrimSpace(m[1])
				ordered = append(ordered, orderedKey{namespace: currentNS, key: k})
			}
		}
	}
	return ordered
}

func getArgs(meta metaDataType, ns, key string) ([]string, bool) {
	m, ok := meta[ns]
	if !ok {
		return nil, false
	}
	a, ok := m[key]
	return a, ok
}

func countPlaceholders(s string) int {
	matches := phRe.FindAllStringSubmatch(s, -1)
	max := -1
	for _, g := range matches {
		if len(g) < 2 {
			continue
		}
		idx := atoiSafe(g[1])
		if idx > max {
			max = idx
		}
	}
	return max + 1
}

// validateSequentialPlaceholders ensures placeholders are sequentially
// numbered from {0} to {expected-1} with no gaps.
func validateSequentialPlaceholders(s string, expected int) error {
	seen := make(map[int]bool)
	matches := phRe.FindAllStringSubmatch(s, -1)
	for _, g := range matches {
		if len(g) < 2 {
			continue
		}
		idx := atoiSafe(g[1])
		seen[idx] = true
	}
	for i := 0; i < expected; i++ {
		if !seen[i] {
			return fmt.Errorf("missing placeholder {%d}", i)
		}
	}
	return nil
}

func atoiSafe(s string) int {
	n := 0
	for _, r := range s {
		if r < '0' || r > '9' {
			break
		}
		n = n*10 + int(r-'0')
	}
	return n
}

func toExportedName(ns, key string) string {
	conv := func(s string) string {
		s = strings.ReplaceAll(s, "-", " ")
		s = strings.ReplaceAll(s, "_", " ")
		parts := strings.Fields(s)
		for i, p := range parts {
			if len(p) == 0 {
				continue
			}
			parts[i] = strings.ToUpper(p[:1]) + p[1:]
		}
		// join and strip non-alphanumeric
		joined := strings.Join(parts, "")
		b := strings.Builder{}
		for _, r := range joined {
			if (r >= 'A' && r <= 'Z') || (r >= 'a' && r <= 'z') || (r >= '0' && r <= '9') {
				b.WriteRune(r)
			}
		}
		out := b.String()
		if out == "" {
			out = "Key"
		}
		// ensure starts with letter for exported name
		r0 := rune(out[0])
		if (r0 < 'A' || r0 > 'Z') && (r0 < 'a' || r0 > 'z') {
			out = "Key" + out
		}
		return out
	}
	return conv(ns) + conv(key)
}

func parseArgSpec(s string) (string, string, error) {
	parts := strings.SplitN(s, ":", 2)
	if len(parts) != 2 {
		return "", "", fmt.Errorf("arg %q must be 'name: type'", s)
	}
	name := sanitizeIdent(strings.TrimSpace(parts[0]))
	typ := strings.TrimSpace(parts[1])
	if !isSupportedType(typ) {
		return "", "", fmt.Errorf("unsupported type %q", typ)
	}
	if name == "" {
		return "", "", errors.New("empty arg name")
	}
	return name, typ, nil
}

func sanitizeIdent(s string) string {
	if s == "" {
		return s
	}
	b := strings.Builder{}
	// If first char is not letter or underscore, prefix underscore
	r0 := rune(s[0])
	if r0 != '_' && (r0 < 'A' || r0 > 'Z') && (r0 < 'a' || r0 > 'z') {
		b.WriteByte('_')
	}
	for _, r := range s {
		if r == '_' || (r >= 'A' && r <= 'Z') || (r >= 'a' && r <= 'z') || (r >= '0' && r <= '9') {
			b.WriteRune(r)
		} else {
			b.WriteByte('_')
		}
	}
	return b.String()
}

func isSupportedType(t string) bool {
	switch t {
	case "string", "int", "int64", "float64", "bool":
		return true
	default:
		return false
	}
}
