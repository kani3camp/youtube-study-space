---
const { class: className = '' } = Astro.props;
---

<div
	id="pomodoro-timer"
	class={`relative flex h-full w-full flex-col items-center justify-center gap-10 rounded-[36px] border border-slate-800/60 bg-slate-900/75 px-14 py-16 text-center shadow-2xl backdrop-blur ${className}`.trim()}
>
	<div class="relative h-[420px] w/[420px]">
		<svg class="h-full w-full -rotate-90" viewBox="0 0 460 460" fill="none">
			<circle cx="230" cy="230" r="200" stroke="rgba(148, 163, 184, 0.32)" stroke-width="40" />
			<circle
				data-role="progress"
				cx="230"
				cy="230"
				r="200"
				stroke="#f97316"
				stroke-width="40"
				stroke-linecap="butt"
				stroke-dasharray="0"
				stroke-dashoffset="0"
			/>
		</svg>
		<div class="pointer-events-none absolute inset-0 flex flex-col items-center justify-center gap-5">
			<span data-role="label" class="font-display text-[1.75rem] font-extrabold uppercase tracking-[0.55em] text-orange-400">STATUS</span>
			<span data-role="time" class="font-mono tabular-nums text-[5.5rem] font-black leading-tight tracking-[0.02em] text-white" style="font-feature-settings: 'tnum', 'lnum'">25:00</span>
		</div>
	</div>
</div>

<script>
	const focusDuration = 25 * 60;
	const breakDuration = 5 * 60;
	const prefillDurationMs = 2000;

	const container = document.getElementById('pomodoro-timer');
	if (!container) {
		throw new Error('Pomodoro timer container not found');
	}

	const labelElement = container.querySelector('[data-role="label"]');
	const timeElement = container.querySelector('[data-role="time"]');
	const progressCircle = container.querySelector('[data-role="progress"]');

	if (!labelElement || !timeElement || !progressCircle) {
		throw new Error('Pomodoro timer elements not found');
	}

	const circumference = 2 * Math.PI * progressCircle.r.baseVal.value;
	progressCircle.style.strokeDasharray = `${circumference}`;
	progressCircle.style.strokeDashoffset = `${circumference}`;

	let isFocus = true;
	let currentDuration = focusDuration;
	let periodStart = performance.now();
	let prefillStart = periodStart;
	let isPrefill = true;
	let animationFrameId;

	const formatTime = (seconds) => {
		const totalSeconds = Math.max(0, Math.ceil(seconds));
		const mins = Math.floor(totalSeconds / 60);
		const secs = totalSeconds % 60;
		return `${String(mins).padStart(2, '0')}:${String(secs).padStart(2, '0')}`;
	};

	const getModeConfig = () =>
		isFocus
			? {
				label: 'FOCUS',
				duration: focusDuration,
				color: '#f97316'
			}
			: {
				label: 'BREAK',
				duration: breakDuration,
				color: '#22c55e'
			};

	const applyModeVisuals = (config) => {
		labelElement.textContent = config.label;
		labelElement.style.color = config.color;
		progressCircle.style.stroke = config.color;
	};

	const startMode = (timestamp = performance.now()) => {
		const config = getModeConfig();
		currentDuration = config.duration;
		periodStart = timestamp;
		prefillStart = timestamp;
		isPrefill = true;
		applyModeVisuals(config);
		timeElement.textContent = formatTime(currentDuration);
		progressCircle.style.strokeDashoffset = `${circumference}`;
	};

	const easeOutCubic = (t) => 1 - Math.pow(1 - t, 3);

	const updateFrame = (timestamp) => {
		const durationMs = currentDuration * 1000;

		if (isPrefill) {
			const elapsedPrefill = timestamp - prefillStart;
			const clampedPrefill = Math.min(elapsedPrefill, durationMs);
			const ratioPrefill = clampedPrefill / durationMs;
			const eased = easeOutCubic(Math.min(elapsedPrefill / prefillDurationMs, 1));
			const targetOffset = circumference * ratioPrefill;
			const interpolatedOffset = circumference - (circumference - targetOffset) * eased;
			progressCircle.style.strokeDashoffset = `${interpolatedOffset}`;
			const remainingSeconds = Math.max((durationMs - clampedPrefill) / 1000, 0);
			timeElement.textContent = formatTime(remainingSeconds);
			if (elapsedPrefill >= prefillDurationMs || clampedPrefill >= durationMs) {
				isPrefill = false;
				periodStart = timestamp - clampedPrefill;
			}
		} else {
			const elapsedMs = timestamp - periodStart;
			const clampedElapsed = Math.min(elapsedMs, durationMs);
			const progressRatio = clampedElapsed / durationMs;
			const remainingSeconds = Math.max((durationMs - clampedElapsed) / 1000, 0);
			timeElement.textContent = formatTime(remainingSeconds);
			progressCircle.style.strokeDashoffset = `${circumference * progressRatio}`;
			if (elapsedMs >= durationMs) {
				isFocus = !isFocus;
				startMode(timestamp);
			}
		}

		animationFrameId = requestAnimationFrame(updateFrame);
	};

	const start = () => {
		startMode();
		if (animationFrameId) {
			cancelAnimationFrame(animationFrameId);
		}
		animationFrameId = requestAnimationFrame(updateFrame);
	};

	start();
</script>
